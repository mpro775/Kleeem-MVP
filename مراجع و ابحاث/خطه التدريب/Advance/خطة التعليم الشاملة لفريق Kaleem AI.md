# خطة التعليم الشاملة لفريق Kaleem AI

**التاريخ:** 14 سبتمبر 2025  
**نوع الوثيقة:** خطة تدريب تقنية شاملة  
**الغرض:** تأهيل الفريق للعمل مع النظام المحسّن والتقنيات الجديدة  
**المدة الإجمالية:** 8 أسابيع (160 ساعة تدريبية)

---

## جدول المحتويات

1. [نظرة عامة على خطة التدريب](#نظرة-عامة-على-خطة-التدريب)
2. [الأسبوع الأول: أساسيات النظام الجديد](#الأسبوع-الأول-أساسيات-النظام-الجديد)
3. [الأسبوع الثاني: الأمان والحماية](#الأسبوع-الثاني-الأمان-والحماية)
4. [الأسبوع الثالث: الأداء والتحسين](#الأسبوع-الثالث-الأداء-والتحسين)
5. [الأسبوع الرابع: المراقبة والمقاييس](#الأسبوع-الرابع-المراقبة-والمقاييس)
6. [الأسبوع الخامس: الاختبارات والجودة](#الأسبوع-الخامس-الاختبارات-والجودة)
7. [الأسبوع السادس: البنية التحتية وCI/CD](#الأسبوع-السادس-البنية-التحتية-وcicd)
8. [الأسبوع السابع: العمليات والصيانة](#الأسبوع-السابع-العمليات-والصيانة)
9. [الأسبوع الثامن: التطبيق العملي والتقييم](#الأسبوع-الثامن-التطبيق-العملي-والتقييم)
10. [الموارد والمراجع](#الموارد-والمراجع)

---

## نظرة عامة على خطة التدريب

### أهداف التدريب

#### الأهداف الرئيسية
1. **إتقان التقنيات الجديدة:** تأهيل الفريق للعمل مع جميع التقنيات المطبقة
2. **فهم المعمارية:** استيعاب البنية الجديدة وأسباب التصميم
3. **تطبيق أفضل الممارسات:** اعتماد معايير الجودة والأمان العالمية
4. **إدارة العمليات:** القدرة على صيانة وتطوير النظام بكفاءة
5. **حل المشاكل:** مهارات التشخيص والإصلاح السريع

#### الأهداف التفصيلية
```
🎯 تقنية: إتقان 15+ تقنية جديدة
🔒 أمان: فهم 35+ ميزة أمنية
⚡ أداء: تطبيق 25+ تحسين أداء
📊 مراقبة: استخدام 10+ أداة مراقبة
🧪 اختبارات: كتابة 300+ اختبار
🏗️ بنية تحتية: إدارة 8+ خدمة
```

### منهجية التدريب

#### النهج التعليمي
1. **التعلم التدريجي:** من الأساسيات إلى المتقدم
2. **التطبيق العملي:** 70% عملي، 30% نظري
3. **التعلم التفاعلي:** ورش عمل ومشاريع جماعية
4. **التقييم المستمر:** اختبارات وتطبيقات عملية
5. **الدعم المستمر:** mentoring ومتابعة فردية

#### أدوات التدريب
```
📚 مواد نظرية: 200+ صفحة توثيق
💻 تطبيقات عملية: 50+ تمرين
🎥 فيديوهات تعليمية: 40+ ساعة
🔬 مختبرات عملية: 8 بيئات تدريب
📝 اختبارات: 25 اختبار تقييمي
🏆 مشاريع: 8 مشاريع تطبيقية
```

### تقسيم الفريق والأدوار

#### المجموعات التدريبية
1. **Backend Developers (2 أشخاص)**
   - التركيز: NestJS, TypeScript, MongoDB, Redis
   - المدة: 8 أسابيع كاملة
   - المستوى: متوسط إلى متقدم

2. **DevOps Engineers (2 أشخاص)**
   - التركيز: Docker, Kubernetes, CI/CD, Monitoring
   - المدة: 6 أسابيع (تركيز على البنية التحتية)
   - المستوى: متقدم

3. **QA Engineers (شخص )**
   - التركيز: Testing, Quality Assurance, Automation
   - المدة: 5 أسابيع (تركيز على الاختبارات)
   - المستوى: متوسط

4. **Security Specialists ( شخص)**
   - التركيز: Security, Authentication, Monitoring
   - المدة: 4 أسابيع (تركيز على الأمان)
   - المستوى: متقدم

#### الجدول الزمني الإجمالي
```
📅 المدة الإجمالية: 8 أسابيع
⏰ ساعات يومية: 4 ساعات تدريب
📊 إجمالي ساعات التدريب: 160 ساعة/شخص
👥 عدد المتدربين: 6 شخص
🎯 إجمالي ساعات التدريب: 1,920 ساعة
```

### معايير التقييم والنجاح

#### مؤشرات الأداء
1. **الاختبارات النظرية:** 80%+ للنجاح
2. **التطبيقات العملية:** إنجاز جميع المشاريع
3. **الحضور والمشاركة:** 90%+ حضور
4. **التقييم النهائي:** مشروع تطبيقي شامل
5. **التقييم المستمر:** متابعة أسبوعية

#### شهادات الإنجاز
```
🏆 شهادة إتمام التدريب الأساسي
🥇 شهادة التخصص التقني
🎖️ شهادة أفضل متدرب
📜 شهادة المشروع التطبيقي
🌟 شهادة الخبير المعتمد
```

---


## الأسبوع الأول: أساسيات النظام الجديد

### اليوم الأول: مقدمة شاملة ونظرة عامة

#### الجلسة الصباحية (9:00 - 12:00): التحول الكبير
**المدة:** 3 ساعات  
**المدرب:** Lead Architect  
**المشاركون:** جميع أعضاء الفريق

**المحتوى:**
1. **مراجعة الوضع السابق (45 دقيقة)**
   ```
   📊 عرض المشاكل القديمة:
   - 55+ مشكلة جوهرية
   - تغطية اختبارات 0.8%
   - 47 ثغرة أمنية
   - أداء كارثي (8.5 ثانية)
   ```

2. **استعراض التحول الجديد (90 دقيقة)**
   ```
   🚀 النتائج المذهلة:
   - أداء محسّن 9,900%
   - أمان من 2/10 إلى 9.5/10
   - جودة من 0.8% إلى 72%
   - وفورات $10.542M سنوياً
   ```

3. **المعمارية الجديدة (45 دقيقة)**
   ```
   🏗️ البنية الجديدة:
   - Microservices architecture
   - Event-driven design
   - Multi-layer caching
   - Advanced security
   ```

**التطبيق العملي:**
- جولة في الكود الجديد
- مقارنة قبل وبعد
- فهم هيكل المشروع

#### الجلسة المسائية (13:00 - 16:00): إعداد البيئة التطويرية
**المدة:** 3 ساعات  
**المدرب:** Senior DevOps Engineer  
**المشاركون:** جميع أعضاء الفريق

**المحتوى:**
1. **إعداد بيئة التطوير (90 دقيقة)**
   ```bash
   # تثبيت الأدوات المطلوبة
   # Node.js 18+
   curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
   sudo apt-get install -y nodejs
   
   # Docker & Docker Compose
   sudo apt-get update
   sudo apt-get install docker.io docker-compose
   
   # MongoDB Compass
   wget https://downloads.mongodb.com/compass/mongodb-compass_1.39.0_amd64.deb
   sudo dpkg -i mongodb-compass_1.39.0_amd64.deb
   
   # Redis CLI
   sudo apt-get install redis-tools
   
   # VS Code Extensions
   code --install-extension ms-vscode.vscode-typescript-next
   code --install-extension bradlc.vscode-tailwindcss
   code --install-extension ms-vscode.vscode-json
   ```

2. **استنساخ وإعداد المشروع (60 دقيقة)**
   ```bash
   # استنساخ المشروع
   git clone https://github.com/kaleem-ai/api.git
   cd api
   
   # تثبيت التبعيات
   npm install
   
   # إعداد متغيرات البيئة
   cp .env.example .env.development
   
   # تشغيل قواعد البيانات
   docker-compose up -d mongodb redis
   
   # تشغيل التطبيق
   npm run start:dev
   ```

3. **فهم أدوات التطوير (30 دقيقة)**
   ```
   🛠️ الأدوات الأساسية:
   - VS Code مع Extensions
   - Postman للـ API testing
   - MongoDB Compass
   - Redis Commander
   - Git & GitHub
   ```

**التطبيق العملي:**
- إعداد البيئة على كل جهاز
- تشغيل المشروع محلياً
- اختبار الاتصال بقواعد البيانات

### اليوم الثاني: NestJS Framework المتقدم

#### الجلسة الصباحية (9:00 - 12:00): أساسيات NestJS
**المدة:** 3 ساعات  
**المدرب:** Senior Backend Developer  
**المشاركون:** Backend Developers + QA Engineers

**المحتوى:**
1. **مفاهيم NestJS الأساسية (90 دقيقة)**
   ```typescript
   // Module System
   @Module({
     imports: [TypeOrmModule.forFeature([User])],
     controllers: [UsersController],
     providers: [UsersService, UsersRepository],
     exports: [UsersService],
   })
   export class UsersModule {}
   
   // Dependency Injection
   @Injectable()
   export class UsersService {
     constructor(
       private readonly usersRepository: UsersRepository,
       private readonly cacheService: CacheService,
     ) {}
   }
   
   // Decorators
   @Controller('users')
   @UseGuards(JwtAuthGuard)
   export class UsersController {
     @Get(':id')
     @UseInterceptors(CacheInterceptor)
     async findOne(@Param('id') id: string) {
       return this.usersService.findById(id);
     }
   }
   ```

2. **Guards, Interceptors, Pipes (60 دقيقة)**
   ```typescript
   // Custom Guard
   @Injectable()
   export class RolesGuard implements CanActivate {
     constructor(private reflector: Reflector) {}
     
     canActivate(context: ExecutionContext): boolean {
       const requiredRoles = this.reflector.getAllAndOverride<Role[]>(
         ROLES_KEY,
         [context.getHandler(), context.getClass()],
       );
       
       if (!requiredRoles) return true;
       
       const { user } = context.switchToHttp().getRequest();
       return requiredRoles.some((role) => user.roles?.includes(role));
     }
   }
   
   // Custom Interceptor
   @Injectable()
   export class LoggingInterceptor implements NestInterceptor {
     intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
       const startTime = Date.now();
       
       return next.handle().pipe(
         tap(() => {
           const duration = Date.now() - startTime;
           console.log(`Request completed in ${duration}ms`);
         }),
       );
     }
   }
   
   // Custom Pipe
   @Injectable()
   export class ParseObjectIdPipe implements PipeTransform {
     transform(value: string): string {
       if (!Types.ObjectId.isValid(value)) {
         throw new BadRequestException('Invalid ObjectId format');
       }
       return value;
     }
   }
   ```

3. **Exception Handling (30 دقيقة)**
   ```typescript
   // Custom Exception Filter
   @Catch(HttpException)
   export class HttpExceptionFilter implements ExceptionFilter {
     catch(exception: HttpException, host: ArgumentsHost) {
       const ctx = host.switchToHttp();
       const response = ctx.getResponse<Response>();
       const request = ctx.getRequest<Request>();
       const status = exception.getStatus();
       
       response.status(status).json({
         statusCode: status,
         timestamp: new Date().toISOString(),
         path: request.url,
         message: exception.message,
       });
     }
   }
   ```

**التطبيق العملي:**
- إنشاء module جديد
- كتابة controller مع guards
- تطبيق interceptors و pipes

#### الجلسة المسائية (13:00 - 16:00): TypeScript المتقدم
**المدة:** 3 ساعات  
**المدرب:** Senior Backend Developer  
**المشاركون:** Backend Developers

**المحتوى:**
1. **Advanced TypeScript Features (120 دقيقة)**
   ```typescript
   // Generic Types
   interface Repository<T> {
     findById(id: string): Promise<T | null>;
     create(entity: Partial<T>): Promise<T>;
     update(id: string, updates: Partial<T>): Promise<T>;
     delete(id: string): Promise<void>;
   }
   
   // Utility Types
   type CreateUserDto = Pick<User, 'email' | 'name' | 'password'>;
   type UpdateUserDto = Partial<Pick<User, 'name' | 'email'>>;
   type UserResponse = Omit<User, 'password' | 'refreshTokens'>;
   
   // Conditional Types
   type ApiResponse<T> = T extends string
     ? { message: T }
     : { data: T; message: string };
   
   // Mapped Types
   type Optional<T> = {
     [P in keyof T]?: T[P];
   };
   
   type Required<T> = {
     [P in keyof T]-?: T[P];
   };
   ```

2. **Decorators والـ Metadata (60 دقيقة)**
   ```typescript
   // Custom Decorator
   export const Roles = (...roles: Role[]) => SetMetadata(ROLES_KEY, roles);
   
   // Property Decorator
   export function Transform(transformFn: (value: any) => any) {
     return function (target: any, propertyKey: string) {
       const descriptor = Object.getOwnPropertyDescriptor(target, propertyKey);
       
       Object.defineProperty(target, propertyKey, {
         get() {
           return transformFn(descriptor?.value);
         },
         set(value) {
           descriptor!.value = value;
         },
       });
     };
   }
   
   // Method Decorator
   export function Cacheable(ttl: number = 300) {
     return function (
       target: any,
       propertyKey: string,
       descriptor: PropertyDescriptor,
     ) {
       const originalMethod = descriptor.value;
       
       descriptor.value = async function (...args: any[]) {
         const cacheKey = `${target.constructor.name}:${propertyKey}:${JSON.stringify(args)}`;
         
         // Check cache first
         const cached = await this.cacheService.get(cacheKey);
         if (cached) return cached;
         
         // Execute method
         const result = await originalMethod.apply(this, args);
         
         // Cache result
         await this.cacheService.set(cacheKey, result, ttl);
         
         return result;
       };
     };
   }
   ```

**التطبيق العملي:**
- كتابة generic repository
- إنشاء custom decorators
- تطبيق advanced types

### اليوم الثالث: قواعد البيانات والتحسين

#### الجلسة الصباحية (9:00 - 12:00): MongoDB المتقدم
**المدة:** 3 ساعات  
**المدرب:** Database Specialist  
**المشاركون:** Backend Developers

**المحتوى:**
1. **Mongoose Schemas المتقدمة (90 دقيقة)**
   ```typescript
   // Advanced Schema Definition
   @Schema({
     timestamps: true,
     toJSON: {
       transform: (doc, ret) => {
         ret.id = ret._id;
         delete ret._id;
         delete ret.__v;
         delete ret.password;
         return ret;
       },
     },
   })
   export class User {
     @Prop({ required: true, unique: true, lowercase: true })
     email: string;
   
     @Prop({ required: true, minlength: 2, maxlength: 50 })
     name: string;
   
     @Prop({ required: true, select: false })
     password: string;
   
     @Prop({ type: [String], enum: Role, default: [Role.USER] })
     roles: Role[];
   
     @Prop({
       type: {
         type: String,
         enum: ['Point'],
         default: 'Point',
       },
       coordinates: {
         type: [Number],
         required: true,
       },
     })
     location: {
       type: string;
       coordinates: [number, number];
     };
   
     @Prop({ type: mongoose.Schema.Types.Mixed })
     metadata: Record<string, any>;
   
     @Prop({ default: Date.now })
     createdAt: Date;
   
     @Prop({ default: Date.now })
     updatedAt: Date;
   }
   ```

2. **Aggregation Pipelines (60 دقيقة)**
   ```typescript
   // Complex Aggregation Example
   async getProductAnalytics(filters: AnalyticsFiltersDto) {
     return this.productModel.aggregate([
       // Match stage
       {
         $match: {
           createdAt: {
             $gte: filters.startDate,
             $lte: filters.endDate,
           },
           status: 'ACTIVE',
         },
       },
       
       // Lookup stage (JOIN)
       {
         $lookup: {
           from: 'categories',
           localField: 'categoryId',
           foreignField: '_id',
           as: 'category',
         },
       },
       
       // Unwind stage
       { $unwind: '$category' },
       
       // Group stage
       {
         $group: {
           _id: '$category.name',
           totalProducts: { $sum: 1 },
           averagePrice: { $avg: '$price' },
           totalRevenue: { $sum: '$price' },
           minPrice: { $min: '$price' },
           maxPrice: { $max: '$price' },
         },
       },
       
       // Sort stage
       { $sort: { totalRevenue: -1 } },
       
       // Limit stage
       { $limit: 10 },
       
       // Project stage
       {
         $project: {
           category: '$_id',
           totalProducts: 1,
           averagePrice: { $round: ['$averagePrice', 2] },
           totalRevenue: { $round: ['$totalRevenue', 2] },
           priceRange: {
             min: '$minPrice',
             max: '$maxPrice',
           },
           _id: 0,
         },
       },
     ]);
   }
   ```

3. **Indexing Strategies (30 دقيقة)**
   ```typescript
   // Index Creation
   @Schema()
   export class Product {
     @Prop({ index: true }) // Simple index
     name: string;
   
     @Prop({ index: 'text' }) // Text index for search
     description: string;
   
     @Prop({ index: true }) // Compound index will be created separately
     categoryId: string;
   
     @Prop({ index: true })
     price: number;
   
     @Prop({ index: '2dsphere' }) // Geospatial index
     location: {
       type: string;
       coordinates: [number, number];
     };
   }
   
   // Compound Indexes
   ProductSchema.index({ categoryId: 1, price: 1 });
   ProductSchema.index({ createdAt: -1, _id: -1 }); // For cursor pagination
   ProductSchema.index({ name: 'text', description: 'text', tags: 'text' });
   ```

**التطبيق العملي:**
- إنشاء schemas معقدة
- كتابة aggregation pipelines
- تطبيق indexing strategies

#### الجلسة المسائية (13:00 - 16:00): Redis والـ Caching
**المدة:** 3 ساعات  
**المدرب:** Performance Engineer  
**المشاركون:** Backend Developers

**المحتوى:**
1. **Redis Data Structures (90 دقيقة)**
   ```typescript
   // Redis Service Implementation
   @Injectable()
   export class RedisService {
     constructor(@Inject('REDIS_CLIENT') private redis: Redis) {}
   
     // Strings
     async setString(key: string, value: string, ttl?: number): Promise<void> {
       if (ttl) {
         await this.redis.setex(key, ttl, value);
       } else {
         await this.redis.set(key, value);
       }
     }
   
     // Hashes
     async setHash(key: string, field: string, value: string): Promise<void> {
       await this.redis.hset(key, field, value);
     }
   
     async getHash(key: string, field?: string): Promise<any> {
       if (field) {
         return this.redis.hget(key, field);
       }
       return this.redis.hgetall(key);
     }
   
     // Lists
     async pushToList(key: string, ...values: string[]): Promise<number> {
       return this.redis.lpush(key, ...values);
     }
   
     async getFromList(key: string, start = 0, stop = -1): Promise<string[]> {
       return this.redis.lrange(key, start, stop);
     }
   
     // Sets
     async addToSet(key: string, ...members: string[]): Promise<number> {
       return this.redis.sadd(key, ...members);
     }
   
     async getSetMembers(key: string): Promise<string[]> {
       return this.redis.smembers(key);
     }
   
     // Sorted Sets
     async addToSortedSet(
       key: string,
       score: number,
       member: string,
     ): Promise<number> {
       return this.redis.zadd(key, score, member);
     }
   
     async getSortedSetRange(
       key: string,
       start = 0,
       stop = -1,
       withScores = false,
     ): Promise<string[]> {
       if (withScores) {
         return this.redis.zrange(key, start, stop, 'WITHSCORES');
       }
       return this.redis.zrange(key, start, stop);
     }
   }
   ```

2. **Multi-Layer Caching Strategy (60 دقيقة)**
   ```typescript
   // Advanced Caching Service
   @Injectable()
   export class CacheService {
     private l1Cache = new Map<string, { value: any; expiry: number }>();
     private readonly L1_TTL = 5 * 60 * 1000; // 5 minutes
   
     constructor(
       @Inject('REDIS_CLIENT') private redis: Redis,
       private readonly metricsService: MetricsService,
     ) {
       // Cleanup L1 cache every minute
       setInterval(() => this.cleanupL1Cache(), 60 * 1000);
     }
   
     async get(key: string): Promise<any> {
       const startTime = Date.now();
   
       // Check L1 cache first (in-memory)
       const l1Entry = this.l1Cache.get(key);
       if (l1Entry && l1Entry.expiry > Date.now()) {
         this.metricsService.incrementCacheHit('L1', this.getKeyPrefix(key));
         return l1Entry.value;
       }
   
       // Check L2 cache (Redis)
       const l2Value = await this.redis.get(key);
       if (l2Value !== null) {
         const parsedValue = JSON.parse(l2Value);
         
         // Update L1 cache
         this.l1Cache.set(key, {
           value: parsedValue,
           expiry: Date.now() + this.L1_TTL,
         });
         
         this.metricsService.incrementCacheHit('L2', this.getKeyPrefix(key));
         return parsedValue;
       }
   
       // Cache miss
       this.metricsService.incrementCacheMiss(this.getKeyPrefix(key));
       return null;
     }
   
     async set(key: string, value: any, ttl = 3600): Promise<void> {
       // Set in L1 cache
       this.l1Cache.set(key, {
         value,
         expiry: Date.now() + Math.min(ttl * 1000, this.L1_TTL),
       });
   
       // Set in L2 cache (Redis)
       await this.redis.setex(key, ttl, JSON.stringify(value));
     }
   
     async invalidate(pattern: string): Promise<void> {
       // Invalidate L1 cache
       for (const key of this.l1Cache.keys()) {
         if (key.includes(pattern)) {
           this.l1Cache.delete(key);
         }
       }
   
       // Invalidate L2 cache
       const keys = await this.redis.keys(`*${pattern}*`);
       if (keys.length > 0) {
         await this.redis.del(...keys);
       }
     }
   
     private cleanupL1Cache(): void {
       const now = Date.now();
       for (const [key, entry] of this.l1Cache.entries()) {
         if (entry.expiry <= now) {
           this.l1Cache.delete(key);
         }
       }
     }
   
     private getKeyPrefix(key: string): string {
       return key.split(':')[0] || 'unknown';
     }
   }
   ```

3. **Cache Patterns (30 دقيقة)**
   ```typescript
   // Cache-Aside Pattern
   async getProduct(id: string): Promise<Product> {
     const cacheKey = `product:${id}`;
     
     // Try cache first
     const cached = await this.cacheService.get(cacheKey);
     if (cached) return cached;
     
     // Load from database
     const product = await this.productRepository.findById(id);
     if (!product) throw new NotFoundException();
     
     // Cache the result
     await this.cacheService.set(cacheKey, product, 600);
     
     return product;
   }
   
   // Write-Through Pattern
   async updateProduct(id: string, updates: UpdateProductDto): Promise<Product> {
     // Update database
     const product = await this.productRepository.update(id, updates);
     
     // Update cache
     const cacheKey = `product:${id}`;
     await this.cacheService.set(cacheKey, product, 600);
     
     return product;
   }
   
   // Write-Behind Pattern
   async createProduct(createDto: CreateProductDto): Promise<Product> {
     const product = await this.productRepository.create(createDto);
     
     // Async cache update
     setImmediate(async () => {
       const cacheKey = `product:${product.id}`;
       await this.cacheService.set(cacheKey, product, 600);
     });
     
     return product;
   }
   ```

**التطبيق العملي:**
- تطبيق Redis data structures
- إنشاء multi-layer caching
- تطبيق cache patterns

### اليوم الرابع: API Design والتوثيق

#### الجلسة الصباحية (9:00 - 12:00): RESTful API Best Practices
**المدة:** 3 ساعات  
**المدرب:** API Architect  
**المشاركون:** Backend Developers + QA Engineers

**المحتوى:**
1. **API Design Principles (90 دقيقة)**
   ```typescript
   // Resource-based URLs
   @Controller('products')
   export class ProductsController {
     // GET /products - List products
     @Get()
     async findAll(@Query() filters: ProductFiltersDto) {
       return this.productsService.findWithFilters(filters);
     }
   
     // GET /products/:id - Get specific product
     @Get(':id')
     async findOne(@Param('id', ParseObjectIdPipe) id: string) {
       return this.productsService.findById(id);
     }
   
     // POST /products - Create product
     @Post()
     @UseGuards(JwtAuthGuard, RolesGuard)
     @Roles(Role.MERCHANT, Role.ADMIN)
     async create(@Body() createProductDto: CreateProductDto) {
       return this.productsService.create(createProductDto);
     }
   
     // PUT /products/:id - Update product (full update)
     @Put(':id')
     @UseGuards(JwtAuthGuard, RolesGuard)
     @Roles(Role.MERCHANT, Role.ADMIN)
     async update(
       @Param('id', ParseObjectIdPipe) id: string,
       @Body() updateProductDto: UpdateProductDto,
     ) {
       return this.productsService.update(id, updateProductDto);
     }
   
     // PATCH /products/:id - Partial update
     @Patch(':id')
     @UseGuards(JwtAuthGuard, RolesGuard)
     @Roles(Role.MERCHANT, Role.ADMIN)
     async partialUpdate(
       @Param('id', ParseObjectIdPipe) id: string,
       @Body() partialUpdateDto: PartialUpdateProductDto,
     ) {
       return this.productsService.partialUpdate(id, partialUpdateDto);
     }
   
     // DELETE /products/:id - Delete product
     @Delete(':id')
     @UseGuards(JwtAuthGuard, RolesGuard)
     @Roles(Role.MERCHANT, Role.ADMIN)
     async remove(@Param('id', ParseObjectIdPipe) id: string) {
       await this.productsService.remove(id);
       return { message: 'Product deleted successfully' };
     }
   
     // Nested resources
     // GET /products/:id/reviews - Get product reviews
     @Get(':id/reviews')
     async getReviews(@Param('id', ParseObjectIdPipe) id: string) {
       return this.reviewsService.findByProductId(id);
     }
   
     // POST /products/:id/reviews - Add review
     @Post(':id/reviews')
     @UseGuards(JwtAuthGuard)
     async addReview(
       @Param('id', ParseObjectIdPipe) id: string,
       @Body() createReviewDto: CreateReviewDto,
       @CurrentUser() user: User,
     ) {
       return this.reviewsService.create(id, createReviewDto, user.id);
     }
   }
   ```

2. **HTTP Status Codes والـ Error Handling (60 دقيقة)**
   ```typescript
   // Custom Exception Classes
   export class ProductNotFoundException extends NotFoundException {
     constructor(id: string) {
       super(`Product with ID ${id} not found`);
     }
   }
   
   export class ProductAlreadyExistsException extends ConflictException {
     constructor(name: string) {
       super(`Product with name "${name}" already exists`);
     }
   }
   
   export class InsufficientStockException extends BadRequestException {
     constructor(available: number, requested: number) {
       super(`Insufficient stock. Available: ${available}, Requested: ${requested}`);
     }
   }
   
   // Global Exception Filter
   @Catch()
   export class AllExceptionsFilter implements ExceptionFilter {
     constructor(private readonly logger: Logger) {}
   
     catch(exception: unknown, host: ArgumentsHost): void {
       const ctx = host.switchToHttp();
       const response = ctx.getResponse<Response>();
       const request = ctx.getRequest<Request>();
   
       let status: number;
       let message: string;
       let details: any;
   
       if (exception instanceof HttpException) {
         status = exception.getStatus();
         const exceptionResponse = exception.getResponse();
         
         if (typeof exceptionResponse === 'string') {
           message = exceptionResponse;
         } else {
           message = (exceptionResponse as any).message || exception.message;
           details = (exceptionResponse as any).details;
         }
       } else if (exception instanceof Error) {
         status = 500;
         message = 'Internal server error';
         this.logger.error(exception.message, exception.stack);
       } else {
         status = 500;
         message = 'Unknown error occurred';
         this.logger.error('Unknown exception', exception);
       }
   
       const errorResponse = {
         statusCode: status,
         timestamp: new Date().toISOString(),
         path: request.url,
         method: request.method,
         message,
         ...(details && { details }),
         ...(process.env.NODE_ENV === 'development' && {
           stack: exception instanceof Error ? exception.stack : undefined,
         }),
       };
   
       response.status(status).json(errorResponse);
     }
   }
   ```

3. **Response Formatting (30 دقيقة)**
   ```typescript
   // Response Interceptor
   @Injectable()
   export class ResponseInterceptor implements NestInterceptor {
     intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
       return next.handle().pipe(
         map((data) => {
           const response = context.switchToHttp().getResponse();
           const statusCode = response.statusCode;
   
           // Don't wrap already formatted responses
           if (data && typeof data === 'object' && 'statusCode' in data) {
             return data;
           }
   
           return {
             statusCode,
             timestamp: new Date().toISOString(),
             data,
             message: this.getSuccessMessage(statusCode),
           };
         }),
       );
     }
   
     private getSuccessMessage(statusCode: number): string {
       switch (statusCode) {
         case 200:
           return 'Request successful';
         case 201:
           return 'Resource created successfully';
         case 204:
           return 'Resource updated successfully';
         default:
           return 'Success';
       }
     }
   }
   ```

**التطبيق العملي:**
- تصميم API endpoints
- تطبيق error handling
- إنشاء response formatting

#### الجلسة المسائية (13:00 - 16:00): Swagger Documentation
**المدة:** 3 ساعات  
**المدرب:** Technical Writer  
**المشاركون:** Backend Developers + QA Engineers

**المحتوى:**
1. **Swagger Setup والـ Configuration (60 دقيقة)**
   ```typescript
   // main.ts - Swagger Configuration
   async function bootstrap() {
     const app = await NestFactory.create(AppModule);
   
     // Swagger Configuration
     const config = new DocumentBuilder()
       .setTitle('Kaleem AI API')
       .setDescription('The Kaleem AI API documentation')
       .setVersion('1.0')
       .addBearerAuth(
         {
           type: 'http',
           scheme: 'bearer',
           bearerFormat: 'JWT',
           name: 'JWT',
           description: 'Enter JWT token',
           in: 'header',
         },
         'JWT-auth',
       )
       .addTag('Authentication', 'User authentication and authorization')
       .addTag('Products', 'Product management operations')
       .addTag('Users', 'User management operations')
       .addTag('Orders', 'Order management operations')
       .addServer('https://api.kaleem.ai', 'Production server')
       .addServer('https://staging-api.kaleem.ai', 'Staging server')
       .addServer('http://localhost:3000', 'Development server')
       .build();
   
     const document = SwaggerModule.createDocument(app, config);
     SwaggerModule.setup('api/docs', app, document, {
       swaggerOptions: {
         persistAuthorization: true,
         tagsSorter: 'alpha',
         operationsSorter: 'alpha',
       },
       customSiteTitle: 'Kaleem AI API Documentation',
       customfavIcon: 'https://kaleem.ai/favicon.ico',
       customCss: '.swagger-ui .topbar { display: none }',
     });
   
     await app.listen(3000);
   }
   ```

2. **API Documentation Decorators (90 دقيقة)**
   ```typescript
   // DTOs with Swagger Decorators
   export class CreateProductDto {
     @ApiProperty({
       description: 'Product name',
       example: 'iPhone 15 Pro',
       minLength: 2,
       maxLength: 100,
     })
     @IsString()
     @MinLength(2)
     @MaxLength(100)
     name: string;
   
     @ApiProperty({
       description: 'Product description',
       example: 'Latest iPhone with advanced features',
       minLength: 10,
       maxLength: 1000,
     })
     @IsString()
     @MinLength(10)
     @MaxLength(1000)
     description: string;
   
     @ApiProperty({
       description: 'Product price in SAR',
       example: 4999.99,
       minimum: 0.01,
       maximum: 999999.99,
     })
     @IsNumber({ maxDecimalPlaces: 2 })
     @Min(0.01)
     @Max(999999.99)
     price: number;
   
     @ApiProperty({
       description: 'Product category ID',
       example: '507f1f77bcf86cd799439011',
     })
     @IsMongoId()
     categoryId: string;
   
     @ApiPropertyOptional({
       description: 'Product tags',
       example: ['electronics', 'smartphone', 'apple'],
       type: [String],
     })
     @IsOptional()
     @IsArray()
     @IsString({ each: true })
     tags?: string[];
   
     @ApiPropertyOptional({
       description: 'Product images',
       example: ['https://example.com/image1.jpg', 'https://example.com/image2.jpg'],
       type: [String],
     })
     @IsOptional()
     @IsArray()
     @IsUrl({}, { each: true })
     imageUrls?: string[];
   }
   
   // Controller with Swagger Decorators
   @ApiTags('Products')
   @Controller('products')
   export class ProductsController {
     @ApiOperation({
       summary: 'Get all products',
       description: 'Retrieve a paginated list of products with optional filtering',
     })
     @ApiResponse({
       status: 200,
       description: 'Products retrieved successfully',
       type: PaginatedProductsResponse,
     })
     @ApiResponse({
       status: 400,
       description: 'Invalid query parameters',
       schema: {
         example: {
           statusCode: 400,
           message: 'Validation failed',
           details: ['limit must be a positive number'],
         },
       },
     })
     @ApiQuery({
       name: 'search',
       required: false,
       description: 'Search term for product name or description',
       example: 'iPhone',
     })
     @ApiQuery({
       name: 'categoryId',
       required: false,
       description: 'Filter by category ID',
       example: '507f1f77bcf86cd799439011',
     })
     @ApiQuery({
       name: 'minPrice',
       required: false,
       description: 'Minimum price filter',
       example: 100,
     })
     @ApiQuery({
       name: 'maxPrice',
       required: false,
       description: 'Maximum price filter',
       example: 5000,
     })
     @ApiQuery({
       name: 'limit',
       required: false,
       description: 'Number of items per page',
       example: 20,
     })
     @Get()
     async findAll(@Query() filters: ProductFiltersDto) {
       return this.productsService.findWithFilters(filters);
     }
   
     @ApiOperation({
       summary: 'Create a new product',
       description: 'Create a new product (requires merchant or admin role)',
     })
     @ApiResponse({
       status: 201,
       description: 'Product created successfully',
       type: ProductResponse,
     })
     @ApiResponse({
       status: 400,
       description: 'Validation error',
     })
     @ApiResponse({
       status: 401,
       description: 'Unauthorized',
     })
     @ApiResponse({
       status: 403,
       description: 'Forbidden - insufficient permissions',
     })
     @ApiResponse({
       status: 409,
       description: 'Product name already exists',
     })
     @ApiBearerAuth('JWT-auth')
     @Post()
     @UseGuards(JwtAuthGuard, RolesGuard)
     @Roles(Role.MERCHANT, Role.ADMIN)
     async create(@Body() createProductDto: CreateProductDto) {
       return this.productsService.create(createProductDto);
     }
   }
   ```

3. **Advanced Documentation Features (30 دقيقة)**
   ```typescript
   // Response DTOs
   export class ProductResponse {
     @ApiProperty({ example: '507f1f77bcf86cd799439011' })
     id: string;
   
     @ApiProperty({ example: 'iPhone 15 Pro' })
     name: string;
   
     @ApiProperty({ example: 'Latest iPhone with advanced features' })
     description: string;
   
     @ApiProperty({ example: 4999.99 })
     price: number;
   
     @ApiProperty({ example: 5249.99 })
     priceWithTax: number;
   
     @ApiProperty({ example: '507f1f77bcf86cd799439012' })
     categoryId: string;
   
     @ApiProperty({ example: '507f1f77bcf86cd799439013' })
     merchantId: string;
   
     @ApiProperty({ enum: ProductStatus, example: ProductStatus.ACTIVE })
     status: ProductStatus;
   
     @ApiProperty({ example: ['electronics', 'smartphone'] })
     tags: string[];
   
     @ApiProperty({ example: ['https://example.com/image1.jpg'] })
     imageUrls: string[];
   
     @ApiProperty({ example: '2023-09-14T10:30:00.000Z' })
     createdAt: string;
   
     @ApiProperty({ example: '2023-09-14T10:30:00.000Z' })
     updatedAt: string;
   }
   
   // Paginated Response
   export class PaginatedProductsResponse {
     @ApiProperty({ type: [ProductResponse] })
     items: ProductResponse[];
   
     @ApiProperty({ example: 'eyJpZCI6IjUwN2YxZjc3YmNmODZjZDc5OTQzOTAxMSJ9' })
     nextCursor: string | null;
   
     @ApiProperty({ example: true })
     hasNextPage: boolean;
   
     @ApiProperty({ example: 1250 })
     estimatedTotal: number;
   }
   ```

**التطبيق العملي:**
- إعداد Swagger documentation
- كتابة API documentation شاملة
- اختبار APIs عبر Swagger UI

### اليوم الخامس: مراجعة وتطبيق عملي

#### الجلسة الصباحية (9:00 - 12:00): مراجعة شاملة
**المدة:** 3 ساعات  
**المدرب:** Lead Architect  
**المشاركون:** جميع أعضاء الفريق

**المحتوى:**
1. **مراجعة المفاهيم الأساسية (90 دقيقة)**
   - NestJS architecture
   - TypeScript advanced features
   - MongoDB optimization
   - Redis caching strategies
   - API design principles

2. **Q&A Session (60 دقيقة)**
   - الإجابة على جميع الأسئلة
   - توضيح النقاط الغامضة
   - مناقشة best practices

3. **خطة الأسبوع القادم (30 دقيقة)**
   - استعراض محتوى الأمان
   - تحديد المتطلبات
   - توزيع المهام التحضيرية

#### الجلسة المسائية (13:00 - 16:00): مشروع تطبيقي
**المدة:** 3 ساعات  
**المدرب:** Senior Backend Developer  
**المشاركون:** Backend Developers

**المشروع:** إنشاء API module كامل
```typescript
// المطلوب: إنشاء Categories API
// 1. Category Entity
// 2. Category DTO classes
// 3. Category Repository
// 4. Category Service
// 5. Category Controller
// 6. Swagger Documentation
// 7. Unit Tests
// 8. Integration Tests
```

**معايير التقييم:**
- صحة التطبيق التقني
- جودة الكود
- اكتمال التوثيق
- تغطية الاختبارات
- اتباع best practices

---


## الأسبوع الثاني: الأمان والحماية

### اليوم السادس: Authentication & Authorization

#### الجلسة الصباحية (9:00 - 12:00): JWT والـ Authentication
**المدة:** 3 ساعات  
**المدرب:** Security Specialist  
**المشاركون:** جميع أعضاء الفريق

**المحتوى:**
1. **JWT Implementation المتقدم (120 دقيقة)**
   ```typescript
   // JWT Service Implementation
   @Injectable()
   export class JwtService {
     constructor(
       private readonly configService: ConfigService,
       private readonly redisService: RedisService,
     ) {}
   
     async generateTokens(payload: JwtPayload): Promise<TokenPair> {
       const accessTokenPayload = {
         sub: payload.userId,
         email: payload.email,
         roles: payload.roles,
         type: 'access',
         iat: Math.floor(Date.now() / 1000),
       };
   
       const refreshTokenPayload = {
         sub: payload.userId,
         type: 'refresh',
         iat: Math.floor(Date.now() / 1000),
         jti: uuidv4(), // Unique token ID
       };
   
       const accessToken = jwt.sign(
         accessTokenPayload,
         this.configService.get('JWT_ACCESS_SECRET'),
         {
           expiresIn: this.configService.get('JWT_ACCESS_EXPIRES_IN', '15m'),
           issuer: this.configService.get('JWT_ISSUER', 'kaleem.ai'),
           audience: this.configService.get('JWT_AUDIENCE', 'kaleem-api'),
         },
       );
   
       const refreshToken = jwt.sign(
         refreshTokenPayload,
         this.configService.get('JWT_REFRESH_SECRET'),
         {
           expiresIn: this.configService.get('JWT_REFRESH_EXPIRES_IN', '7d'),
           issuer: this.configService.get('JWT_ISSUER', 'kaleem.ai'),
           audience: this.configService.get('JWT_AUDIENCE', 'kaleem-api'),
         },
       );
   
       // Store refresh token in Redis with expiration
       const refreshTokenKey = `refresh_token:${payload.userId}:${refreshTokenPayload.jti}`;
       await this.redisService.setex(
         refreshTokenKey,
         7 * 24 * 60 * 60, // 7 days
         JSON.stringify({
           userId: payload.userId,
           tokenId: refreshTokenPayload.jti,
           createdAt: new Date().toISOString(),
         }),
       );
   
       return {
         accessToken,
         refreshToken,
         accessTokenExpiresIn: 15 * 60, // 15 minutes in seconds
         refreshTokenExpiresIn: 7 * 24 * 60 * 60, // 7 days in seconds
       };
     }
   
     async verifyAccessToken(token: string): Promise<JwtPayload> {
       try {
         const decoded = jwt.verify(
           token,
           this.configService.get('JWT_ACCESS_SECRET'),
           {
             issuer: this.configService.get('JWT_ISSUER'),
             audience: this.configService.get('JWT_AUDIENCE'),
           },
         ) as any;
   
         if (decoded.type !== 'access') {
           throw new UnauthorizedException('Invalid token type');
         }
   
         // Check if token is blacklisted
         const isBlacklisted = await this.redisService.get(`blacklist:${token}`);
         if (isBlacklisted) {
           throw new UnauthorizedException('Token has been revoked');
         }
   
         return {
           userId: decoded.sub,
           email: decoded.email,
           roles: decoded.roles,
         };
       } catch (error) {
         if (error instanceof jwt.JsonWebTokenError) {
           throw new UnauthorizedException('Invalid token');
         }
         if (error instanceof jwt.TokenExpiredError) {
           throw new UnauthorizedException('Token has expired');
         }
         throw error;
       }
     }
   
     async refreshTokens(refreshToken: string): Promise<TokenPair> {
       try {
         const decoded = jwt.verify(
           refreshToken,
           this.configService.get('JWT_REFRESH_SECRET'),
           {
             issuer: this.configService.get('JWT_ISSUER'),
             audience: this.configService.get('JWT_AUDIENCE'),
           },
         ) as any;
   
         if (decoded.type !== 'refresh') {
           throw new UnauthorizedException('Invalid token type');
         }
   
         // Check if refresh token exists in Redis
         const refreshTokenKey = `refresh_token:${decoded.sub}:${decoded.jti}`;
         const storedToken = await this.redisService.get(refreshTokenKey);
         
         if (!storedToken) {
           throw new UnauthorizedException('Refresh token not found or expired');
         }
   
         // Get user data
         const user = await this.userService.findById(decoded.sub);
         if (!user) {
           throw new UnauthorizedException('User not found');
         }
   
         // Revoke old refresh token
         await this.redisService.del(refreshTokenKey);
   
         // Generate new token pair
         return this.generateTokens({
           userId: user.id,
           email: user.email,
           roles: user.roles,
         });
       } catch (error) {
         if (error instanceof jwt.JsonWebTokenError) {
           throw new UnauthorizedException('Invalid refresh token');
         }
         if (error instanceof jwt.TokenExpiredError) {
           throw new UnauthorizedException('Refresh token has expired');
         }
         throw error;
       }
     }
   
     async revokeToken(token: string): Promise<void> {
       try {
         const decoded = jwt.decode(token) as any;
         if (!decoded) return;
   
         // Add to blacklist with remaining TTL
         const now = Math.floor(Date.now() / 1000);
         const remainingTTL = decoded.exp - now;
         
         if (remainingTTL > 0) {
           await this.redisService.setex(`blacklist:${token}`, remainingTTL, 'revoked');
         }
       } catch (error) {
         // Ignore errors in token revocation
       }
     }
   
     async revokeAllUserTokens(userId: string): Promise<void> {
       // Remove all refresh tokens for user
       const pattern = `refresh_token:${userId}:*`;
       const keys = await this.redisService.keys(pattern);
       
       if (keys.length > 0) {
         await this.redisService.del(...keys);
       }
     }
   }
   ```

2. **Guards Implementation (60 دقيقة)**
   ```typescript
   // JWT Auth Guard
   @Injectable()
   export class JwtAuthGuard implements CanActivate {
     constructor(
       private readonly jwtService: JwtService,
       private readonly userService: UserService,
       private readonly metricsService: MetricsService,
     ) {}
   
     async canActivate(context: ExecutionContext): Promise<boolean> {
       const request = context.switchToHttp().getRequest();
       const token = this.extractTokenFromHeader(request);
   
       if (!token) {
         this.metricsService.incrementSecurityEvent('auth_missing_token');
         throw new UnauthorizedException('Access token is required');
       }
   
       try {
         const payload = await this.jwtService.verifyAccessToken(token);
         
         // Get fresh user data
         const user = await this.userService.findById(payload.userId);
         if (!user) {
           this.metricsService.incrementSecurityEvent('auth_user_not_found');
           throw new UnauthorizedException('User not found');
         }
   
         if (!user.isActive) {
           this.metricsService.incrementSecurityEvent('auth_user_inactive');
           throw new UnauthorizedException('User account is inactive');
         }
   
         // Attach user to request
         request.user = user;
         request.tokenPayload = payload;
   
         this.metricsService.incrementSecurityEvent('auth_success');
         return true;
       } catch (error) {
         this.metricsService.incrementSecurityEvent('auth_token_invalid');
         throw new UnauthorizedException('Invalid or expired token');
       }
     }
   
     private extractTokenFromHeader(request: Request): string | undefined {
       const [type, token] = request.headers.authorization?.split(' ') ?? [];
       return type === 'Bearer' ? token : undefined;
     }
   }
   
   // Roles Guard
   @Injectable()
   export class RolesGuard implements CanActivate {
     constructor(
       private reflector: Reflector,
       private readonly metricsService: MetricsService,
     ) {}
   
     canActivate(context: ExecutionContext): boolean {
       const requiredRoles = this.reflector.getAllAndOverride<Role[]>(ROLES_KEY, [
         context.getHandler(),
         context.getClass(),
       ]);
   
       if (!requiredRoles) {
         return true;
       }
   
       const { user } = context.switchToHttp().getRequest();
       
       if (!user) {
         this.metricsService.incrementSecurityEvent('rbac_no_user');
         return false;
       }
   
       const hasRole = requiredRoles.some((role) => user.roles?.includes(role));
       
       if (!hasRole) {
         this.metricsService.incrementSecurityEvent('rbac_insufficient_permissions');
         return false;
       }
   
       this.metricsService.incrementSecurityEvent('rbac_access_granted');
       return true;
     }
   }
   
   // API Key Guard
   @Injectable()
   export class ApiKeyGuard implements CanActivate {
     constructor(
       private readonly apiKeyService: ApiKeyService,
       private readonly metricsService: MetricsService,
     ) {}
   
     async canActivate(context: ExecutionContext): Promise<boolean> {
       const request = context.switchToHttp().getRequest();
       const apiKey = request.headers['x-api-key'];
   
       if (!apiKey) {
         this.metricsService.incrementSecurityEvent('api_key_missing');
         throw new UnauthorizedException('API key is required');
       }
   
       const isValid = await this.apiKeyService.validateApiKey(apiKey);
       
       if (!isValid) {
         this.metricsService.incrementSecurityEvent('api_key_invalid');
         throw new UnauthorizedException('Invalid API key');
       }
   
       this.metricsService.incrementSecurityEvent('api_key_valid');
       return true;
     }
   }
   ```

**التطبيق العملي:**
- تطبيق JWT authentication
- إنشاء custom guards
- اختبار authentication flow

#### الجلسة المسائية (13:00 - 16:00): Password Security & Encryption
**المدة:** 3 ساعات  
**المدرب:** Security Specialist  
**المشاركون:** Backend Developers

**المحتوى:**
1. **Password Hashing المتقدم (90 دقيقة)**
   ```typescript
   // Password Service
   @Injectable()
   export class PasswordService {
     private readonly saltRounds = 12;
     private readonly pepperSecret: string;
   
     constructor(private readonly configService: ConfigService) {
       this.pepperSecret = this.configService.get('PASSWORD_PEPPER_SECRET');
       if (!this.pepperSecret) {
         throw new Error('PASSWORD_PEPPER_SECRET is required');
       }
     }
   
     async hashPassword(plainPassword: string): Promise<string> {
       // Input validation
       this.validatePassword(plainPassword);
   
       // Add pepper (secret salt)
       const pepperedPassword = this.addPepper(plainPassword);
   
       // Generate salt and hash
       const salt = await bcrypt.genSalt(this.saltRounds);
       const hashedPassword = await bcrypt.hash(pepperedPassword, salt);
   
       return hashedPassword;
     }
   
     async verifyPassword(plainPassword: string, hashedPassword: string): Promise<boolean> {
       try {
         // Add pepper
         const pepperedPassword = this.addPepper(plainPassword);
   
         // Verify with bcrypt
         return await bcrypt.compare(pepperedPassword, hashedPassword);
       } catch (error) {
         // Log security event
         console.error('Password verification error:', error);
         return false;
       }
     }
   
     private validatePassword(password: string): void {
       if (!password || password.length < 8) {
         throw new BadRequestException('Password must be at least 8 characters long');
       }
   
       if (password.length > 128) {
         throw new BadRequestException('Password is too long');
       }
   
       // Check for common patterns
       if (this.isCommonPassword(password)) {
         throw new BadRequestException('Password is too common');
       }
   
       // Strength requirements
       const hasUpperCase = /[A-Z]/.test(password);
       const hasLowerCase = /[a-z]/.test(password);
       const hasNumbers = /\d/.test(password);
       const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(password);
   
       const strengthScore = [hasUpperCase, hasLowerCase, hasNumbers, hasSpecialChar]
         .filter(Boolean).length;
   
       if (strengthScore < 3) {
         throw new BadRequestException(
           'Password must contain at least 3 of: uppercase, lowercase, numbers, special characters'
         );
       }
     }
   
     private addPepper(password: string): string {
       return crypto
         .createHmac('sha256', this.pepperSecret)
         .update(password)
         .digest('hex');
     }
   
     private isCommonPassword(password: string): boolean {
       const commonPasswords = [
         'password', '123456', '123456789', 'qwerty', 'abc123',
         'password123', 'admin', 'letmein', 'welcome', 'monkey'
       ];
       
       return commonPasswords.includes(password.toLowerCase());
     }
   
     generateSecurePassword(length = 16): string {
       const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*';
       let password = '';
       
       for (let i = 0; i < length; i++) {
         const randomIndex = crypto.randomInt(0, charset.length);
         password += charset[randomIndex];
       }
       
       return password;
     }
   
     async checkPasswordStrength(password: string): Promise<PasswordStrength> {
       const checks = {
         length: password.length >= 8,
         uppercase: /[A-Z]/.test(password),
         lowercase: /[a-z]/.test(password),
         numbers: /\d/.test(password),
         specialChars: /[!@#$%^&*(),.?":{}|<>]/.test(password),
         notCommon: !this.isCommonPassword(password),
       };
   
       const score = Object.values(checks).filter(Boolean).length;
       
       let strength: 'weak' | 'medium' | 'strong' | 'very-strong';
       if (score <= 2) strength = 'weak';
       else if (score <= 4) strength = 'medium';
       else if (score <= 5) strength = 'strong';
       else strength = 'very-strong';
   
       return {
         score,
         strength,
         checks,
         suggestions: this.getPasswordSuggestions(checks),
       };
     }
   
     private getPasswordSuggestions(checks: Record<string, boolean>): string[] {
       const suggestions: string[] = [];
       
       if (!checks.length) suggestions.push('Use at least 8 characters');
       if (!checks.uppercase) suggestions.push('Add uppercase letters');
       if (!checks.lowercase) suggestions.push('Add lowercase letters');
       if (!checks.numbers) suggestions.push('Add numbers');
       if (!checks.specialChars) suggestions.push('Add special characters');
       if (!checks.notCommon) suggestions.push('Avoid common passwords');
       
       return suggestions;
     }
   }
   ```

2. **Encryption Service (60 دقيقة)**
   ```typescript
   // Encryption Service
   @Injectable()
   export class EncryptionService {
     private readonly algorithm = 'aes-256-gcm';
     private readonly keyLength = 32; // 256 bits
     private readonly ivLength = 16; // 128 bits
     private readonly tagLength = 16; // 128 bits
     private readonly encryptionKey: Buffer;
   
     constructor(private readonly configService: ConfigService) {
       const key = this.configService.get('ENCRYPTION_KEY');
       if (!key) {
         throw new Error('ENCRYPTION_KEY is required');
       }
       
       this.encryptionKey = crypto.scryptSync(key, 'salt', this.keyLength);
     }
   
     encrypt(plaintext: string): EncryptedData {
       try {
         // Generate random IV
         const iv = crypto.randomBytes(this.ivLength);
         
         // Create cipher
         const cipher = crypto.createCipher(this.algorithm, this.encryptionKey, { iv });
         
         // Encrypt data
         let encrypted = cipher.update(plaintext, 'utf8', 'hex');
         encrypted += cipher.final('hex');
         
         // Get authentication tag
         const tag = cipher.getAuthTag();
         
         return {
           encrypted,
           iv: iv.toString('hex'),
           tag: tag.toString('hex'),
         };
       } catch (error) {
         throw new InternalServerErrorException('Encryption failed');
       }
     }
   
     decrypt(encryptedData: EncryptedData): string {
       try {
         // Convert hex strings back to buffers
         const iv = Buffer.from(encryptedData.iv, 'hex');
         const tag = Buffer.from(encryptedData.tag, 'hex');
         
         // Create decipher
         const decipher = crypto.createDecipher(this.algorithm, this.encryptionKey, { iv });
         decipher.setAuthTag(tag);
         
         // Decrypt data
         let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
         decrypted += decipher.final('utf8');
         
         return decrypted;
       } catch (error) {
         throw new InternalServerErrorException('Decryption failed');
       }
     }
   
     // For sensitive data that needs to be searchable
     encryptDeterministic(plaintext: string, context: string): string {
       const contextHash = crypto.createHash('sha256').update(context).digest();
       const cipher = crypto.createCipher('aes-256-cbc', this.encryptionKey, { iv: contextHash.slice(0, 16) });
       
       let encrypted = cipher.update(plaintext, 'utf8', 'hex');
       encrypted += cipher.final('hex');
       
       return encrypted;
     }
   
     decryptDeterministic(encrypted: string, context: string): string {
       const contextHash = crypto.createHash('sha256').update(context).digest();
       const decipher = crypto.createDecipher('aes-256-cbc', this.encryptionKey, { iv: contextHash.slice(0, 16) });
       
       let decrypted = decipher.update(encrypted, 'hex', 'utf8');
       decrypted += decipher.final('utf8');
       
       return decrypted;
     }
   
     // Hash function for data integrity
     hash(data: string): string {
       return crypto.createHash('sha256').update(data).digest('hex');
     }
   
     // HMAC for message authentication
     hmac(data: string, secret?: string): string {
       const key = secret || this.configService.get('HMAC_SECRET');
       return crypto.createHmac('sha256', key).update(data).digest('hex');
     }
   
     // Verify HMAC
     verifyHmac(data: string, signature: string, secret?: string): boolean {
       const expectedSignature = this.hmac(data, secret);
       return crypto.timingSafeEqual(
         Buffer.from(signature, 'hex'),
         Buffer.from(expectedSignature, 'hex')
       );
     }
   
     // Generate secure random tokens
     generateSecureToken(length = 32): string {
       return crypto.randomBytes(length).toString('hex');
     }
   
     // Generate cryptographically secure random numbers
     generateSecureNumber(min: number, max: number): number {
       const range = max - min + 1;
       const bytesNeeded = Math.ceil(Math.log2(range) / 8);
       const maxValue = Math.pow(256, bytesNeeded);
       const threshold = maxValue - (maxValue % range);
       
       let randomValue;
       do {
         const randomBytes = crypto.randomBytes(bytesNeeded);
         randomValue = randomBytes.readUIntBE(0, bytesNeeded);
       } while (randomValue >= threshold);
       
       return min + (randomValue % range);
     }
   }
   ```

3. **Secure Data Storage (30 دقيقة)**
   ```typescript
   // Secure User Entity
   @Schema({
     timestamps: true,
     toJSON: {
       transform: (doc, ret) => {
         ret.id = ret._id;
         delete ret._id;
         delete ret.__v;
         delete ret.password;
         delete ret.encryptedData;
         return ret;
       },
     },
   })
   export class User {
     @Prop({ required: true, unique: true })
     email: string;
   
     @Prop({ required: true })
     name: string;
   
     @Prop({ required: true, select: false })
     password: string;
   
     @Prop({ type: mongoose.Schema.Types.Mixed, select: false })
     encryptedData: {
       phone?: EncryptedData;
       address?: EncryptedData;
       nationalId?: EncryptedData;
     };
   
     @Prop({ default: true })
     isActive: boolean;
   
     @Prop({ default: false })
     isEmailVerified: boolean;
   
     @Prop({ type: [String], enum: Role, default: [Role.USER] })
     roles: Role[];
   
     @Prop()
     lastLoginAt: Date;
   
     @Prop()
     passwordChangedAt: Date;
   
     @Prop({ default: 0 })
     failedLoginAttempts: number;
   
     @Prop()
     lockedUntil: Date;
   }
   
   // Secure User Service
   @Injectable()
   export class UserService {
     constructor(
       @InjectModel(User.name) private userModel: Model<User>,
       private readonly passwordService: PasswordService,
       private readonly encryptionService: EncryptionService,
     ) {}
   
     async createUser(createUserDto: CreateUserDto): Promise<User> {
       // Hash password
       const hashedPassword = await this.passwordService.hashPassword(createUserDto.password);
       
       // Encrypt sensitive data
       const encryptedData: any = {};
       if (createUserDto.phone) {
         encryptedData.phone = this.encryptionService.encrypt(createUserDto.phone);
       }
       if (createUserDto.address) {
         encryptedData.address = this.encryptionService.encrypt(createUserDto.address);
       }
       if (createUserDto.nationalId) {
         encryptedData.nationalId = this.encryptionService.encrypt(createUserDto.nationalId);
       }
   
       const user = new this.userModel({
         ...createUserDto,
         password: hashedPassword,
         encryptedData,
       });
   
       return user.save();
     }
   
     async getUserWithDecryptedData(userId: string): Promise<UserWithDecryptedData> {
       const user = await this.userModel.findById(userId).select('+encryptedData').exec();
       if (!user) throw new NotFoundException('User not found');
   
       // Decrypt sensitive data
       const decryptedData: any = {};
       if (user.encryptedData?.phone) {
         decryptedData.phone = this.encryptionService.decrypt(user.encryptedData.phone);
       }
       if (user.encryptedData?.address) {
         decryptedData.address = this.encryptionService.decrypt(user.encryptedData.address);
       }
       if (user.encryptedData?.nationalId) {
         decryptedData.nationalId = this.encryptionService.decrypt(user.encryptedData.nationalId);
       }
   
       return {
         ...user.toJSON(),
         ...decryptedData,
       };
     }
   }
   ```

**التطبيق العملي:**
- تطبيق password hashing
- إنشاء encryption service
- تأمين البيانات الحساسة

### اليوم السابع: Input Validation & Sanitization

#### الجلسة الصباحية (9:00 - 12:00): Data Validation المتقدم
**المدة:** 3 ساعات  
**المدرب:** Security Specialist  
**المشاركون:** Backend Developers + QA Engineers

**المحتوى:**
1. **Custom Validation Pipes (120 دقيقة)**
   ```typescript
   // Advanced Validation Pipe
   @Injectable()
   export class AdvancedValidationPipe implements PipeTransform {
     constructor(
       private readonly options: ValidationPipeOptions = {},
       private readonly sanitizationService: SanitizationService,
       private readonly metricsService: MetricsService,
     ) {}
   
     async transform(value: any, metadata: ArgumentMetadata): Promise<any> {
       const { metatype } = metadata;
       
       if (!metatype || !this.toValidate(metatype)) {
         return value;
       }
   
       // Sanitize input first
       const sanitizedValue = await this.sanitizationService.sanitize(value);
   
       // Validate with class-validator
       const object = plainToClass(metatype, sanitizedValue);
       const errors = await validate(object, {
         whitelist: true,
         forbidNonWhitelisted: true,
         transform: true,
         ...this.options,
       });
   
       if (errors.length > 0) {
         this.metricsService.incrementSecurityEvent('validation_failed');
         throw new BadRequestException({
           message: 'Validation failed',
           errors: this.formatErrors(errors),
         });
       }
   
       this.metricsService.incrementSecurityEvent('validation_success');
       return object;
     }
   
     private toValidate(metatype: Function): boolean {
       const types: Function[] = [String, Boolean, Number, Array, Object];
       return !types.includes(metatype);
     }
   
     private formatErrors(errors: ValidationError[]): any[] {
       return errors.map(error => ({
         property: error.property,
         value: error.value,
         constraints: error.constraints,
         children: error.children?.length > 0 ? this.formatErrors(error.children) : undefined,
       }));
     }
   }
   
   // Custom Validators
   export function IsStrongPassword(validationOptions?: ValidationOptions) {
     return function (object: Object, propertyName: string) {
       registerDecorator({
         name: 'isStrongPassword',
         target: object.constructor,
         propertyName: propertyName,
         options: validationOptions,
         validator: {
           validate(value: any) {
             if (typeof value !== 'string') return false;
             
             const hasUpperCase = /[A-Z]/.test(value);
             const hasLowerCase = /[a-z]/.test(value);
             const hasNumbers = /\d/.test(value);
             const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(value);
             const isLongEnough = value.length >= 8;
             
             return hasUpperCase && hasLowerCase && hasNumbers && hasSpecialChar && isLongEnough;
           },
           defaultMessage() {
             return 'Password must contain uppercase, lowercase, numbers, special characters and be at least 8 characters long';
           },
         },
       });
     };
   }
   
   export function IsValidObjectId(validationOptions?: ValidationOptions) {
     return function (object: Object, propertyName: string) {
       registerDecorator({
         name: 'isValidObjectId',
         target: object.constructor,
         propertyName: propertyName,
         options: validationOptions,
         validator: {
           validate(value: any) {
             return typeof value === 'string' && Types.ObjectId.isValid(value);
           },
           defaultMessage() {
             return 'Invalid ObjectId format';
           },
         },
       });
     };
   }
   
   export function IsNotProfane(validationOptions?: ValidationOptions) {
     return function (object: Object, propertyName: string) {
       registerDecorator({
         name: 'isNotProfane',
         target: object.constructor,
         propertyName: propertyName,
         options: validationOptions,
         validator: {
           validate(value: any) {
             if (typeof value !== 'string') return true;
             
             const profaneWords = ['badword1', 'badword2']; // Load from config
             const lowerValue = value.toLowerCase();
             
             return !profaneWords.some(word => lowerValue.includes(word));
           },
           defaultMessage() {
             return 'Text contains inappropriate content';
           },
         },
       });
     };
   }
   
   export function IsValidPhoneNumber(validationOptions?: ValidationOptions) {
     return function (object: Object, propertyName: string) {
       registerDecorator({
         name: 'isValidPhoneNumber',
         target: object.constructor,
         propertyName: propertyName,
         options: validationOptions,
         validator: {
           validate(value: any) {
             if (typeof value !== 'string') return false;
             
             // Saudi phone number format: +966XXXXXXXXX or 05XXXXXXXX
             const saudiPhoneRegex = /^(\+966|0)?5[0-9]{8}$/;
             return saudiPhoneRegex.test(value.replace(/\s/g, ''));
           },
           defaultMessage() {
             return 'Invalid Saudi phone number format';
           },
         },
       });
     };
   }
   ```

2. **Input Sanitization (60 دقيقة)**
   ```typescript
   // Sanitization Service
   @Injectable()
   export class SanitizationService {
     constructor(private readonly configService: ConfigService) {}
   
     async sanitize(input: any): Promise<any> {
       if (typeof input === 'string') {
         return this.sanitizeString(input);
       }
       
       if (Array.isArray(input)) {
         return Promise.all(input.map(item => this.sanitize(item)));
       }
       
       if (typeof input === 'object' && input !== null) {
         return this.sanitizeObject(input);
       }
       
       return input;
     }
   
     private sanitizeString(str: string): string {
       // Remove null bytes
       str = str.replace(/\0/g, '');
       
       // Trim whitespace
       str = str.trim();
       
       // Remove control characters except newlines and tabs
       str = str.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '');
       
       // Normalize unicode
       str = str.normalize('NFC');
       
       // Remove excessive whitespace
       str = str.replace(/\s+/g, ' ');
       
       return str;
     }
   
     private async sanitizeObject(obj: any): Promise<any> {
       const sanitized: any = {};
       
       for (const [key, value] of Object.entries(obj)) {
         const sanitizedKey = this.sanitizeString(key);
         sanitized[sanitizedKey] = await this.sanitize(value);
       }
       
       return sanitized;
     }
   
     sanitizeHtml(html: string): string {
       // Use DOMPurify or similar library
       return DOMPurify.sanitize(html, {
         ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'p', 'br'],
         ALLOWED_ATTR: [],
       });
     }
   
     sanitizeFileName(fileName: string): string {
       // Remove dangerous characters
       return fileName
         .replace(/[^a-zA-Z0-9._-]/g, '')
         .replace(/\.{2,}/g, '.')
         .substring(0, 255);
     }
   
     sanitizeUrl(url: string): string {
       try {
         const parsed = new URL(url);
         
         // Only allow http and https
         if (!['http:', 'https:'].includes(parsed.protocol)) {
           throw new Error('Invalid protocol');
         }
         
         return parsed.toString();
       } catch {
         throw new BadRequestException('Invalid URL format');
       }
     }
   
     sanitizeEmail(email: string): string {
       return email.toLowerCase().trim();
     }
   
     sanitizeSqlInput(input: string): string {
       // Remove SQL injection patterns
       const sqlPatterns = [
         /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION|SCRIPT)\b)/gi,
         /(--|\/\*|\*\/|;|'|"|`)/g,
       ];
       
       let sanitized = input;
       sqlPatterns.forEach(pattern => {
         sanitized = sanitized.replace(pattern, '');
       });
       
       return sanitized;
     }
   
     sanitizeNoSqlInput(input: any): any {
       if (typeof input === 'string') {
         // Remove MongoDB operators
         return input.replace(/^\$/, '');
       }
       
       if (typeof input === 'object' && input !== null) {
         const sanitized: any = {};
         
         for (const [key, value] of Object.entries(input)) {
           // Remove keys starting with $
           if (!key.startsWith('$')) {
             sanitized[key] = this.sanitizeNoSqlInput(value);
           }
         }
         
         return sanitized;
       }
       
       return input;
     }
   }
   ```

**التطبيق العملي:**
- إنشاء custom validators
- تطبيق input sanitization
- اختبار validation scenarios

#### الجلسة المسائية (13:00 - 16:00): Security Headers & CORS
**المدة:** 3 ساعات  
**المدرب:** Security Specialist  
**المشاركون:** Backend Developers + DevOps Engineers

**المحتوى:**
1. **Security Headers Implementation (120 دقيقة)**
   ```typescript
   // Security Headers Middleware
   @Injectable()
   export class SecurityHeadersMiddleware implements NestMiddleware {
     use(req: Request, res: Response, next: NextFunction) {
       // Content Security Policy
       res.setHeader(
         'Content-Security-Policy',
         "default-src 'self'; " +
         "script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; " +
         "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; " +
         "font-src 'self' https://fonts.gstatic.com; " +
         "img-src 'self' data: https:; " +
         "connect-src 'self' https://api.kaleem.ai; " +
         "frame-ancestors 'none'; " +
         "base-uri 'self'; " +
         "form-action 'self';"
       );
   
       // X-Frame-Options
       res.setHeader('X-Frame-Options', 'DENY');
   
       // X-Content-Type-Options
       res.setHeader('X-Content-Type-Options', 'nosniff');
   
       // X-XSS-Protection
       res.setHeader('X-XSS-Protection', '1; mode=block');
   
       // Referrer Policy
       res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
   
       // Strict Transport Security
       res.setHeader(
         'Strict-Transport-Security',
         'max-age=31536000; includeSubDomains; preload'
       );
   
       // Permissions Policy
       res.setHeader(
         'Permissions-Policy',
         'camera=(), microphone=(), geolocation=(), payment=()'
       );
   
       // Remove server information
       res.removeHeader('X-Powered-By');
       res.setHeader('Server', 'Kaleem-API');
   
       // Cache Control for sensitive endpoints
       if (req.path.includes('/auth/') || req.path.includes('/admin/')) {
         res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, private');
         res.setHeader('Pragma', 'no-cache');
         res.setHeader('Expires', '0');
       }
   
       next();
     }
   }
   
   // CORS Configuration
   export const corsOptions: CorsOptions = {
     origin: (origin, callback) => {
       const allowedOrigins = [
         'https://kaleem.ai',
         'https://www.kaleem.ai',
         'https://admin.kaleem.ai',
         'https://staging.kaleem.ai',
       ];
   
       // Allow requests with no origin (mobile apps, etc.)
       if (!origin) return callback(null, true);
   
       // Check if origin is allowed
       if (allowedOrigins.includes(origin)) {
         return callback(null, true);
       }
   
       // Allow localhost in development
       if (process.env.NODE_ENV === 'development' && origin.includes('localhost')) {
         return callback(null, true);
       }
   
       return callback(new Error('Not allowed by CORS'));
     },
     methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],
     allowedHeaders: [
       'Origin',
       'X-Requested-With',
       'Content-Type',
       'Accept',
       'Authorization',
       'X-API-Key',
       'X-Request-ID',
     ],
     exposedHeaders: [
       'X-Total-Count',
       'X-Page-Count',
       'X-Current-Page',
       'X-Rate-Limit-Remaining',
     ],
     credentials: true,
     maxAge: 86400, // 24 hours
   };
   
   // Rate Limiting
   @Injectable()
   export class RateLimitingMiddleware implements NestMiddleware {
     private readonly limiter: Map<string, { count: number; resetTime: number }> = new Map();
     private readonly limits = {
       '/auth/login': { requests: 5, window: 15 * 60 * 1000 }, // 5 requests per 15 minutes
       '/auth/register': { requests: 3, window: 60 * 60 * 1000 }, // 3 requests per hour
       '/auth/forgot-password': { requests: 3, window: 60 * 60 * 1000 },
       default: { requests: 100, window: 15 * 60 * 1000 }, // 100 requests per 15 minutes
     };
   
     constructor(
       private readonly redisService: RedisService,
       private readonly metricsService: MetricsService,
     ) {
       // Cleanup expired entries every minute
       setInterval(() => this.cleanup(), 60 * 1000);
     }
   
     async use(req: Request, res: Response, next: NextFunction) {
       const clientId = this.getClientId(req);
       const endpoint = this.getEndpointKey(req.path);
       const limit = this.limits[endpoint] || this.limits.default;
       
       const key = `rate_limit:${clientId}:${endpoint}`;
       
       try {
         // Use Redis for distributed rate limiting
         const current = await this.redisService.incr(key);
         
         if (current === 1) {
           // Set expiration on first request
           await this.redisService.expire(key, Math.ceil(limit.window / 1000));
         }
         
         const ttl = await this.redisService.ttl(key);
         
         // Set rate limit headers
         res.setHeader('X-RateLimit-Limit', limit.requests);
         res.setHeader('X-RateLimit-Remaining', Math.max(0, limit.requests - current));
         res.setHeader('X-RateLimit-Reset', new Date(Date.now() + ttl * 1000).toISOString());
         
         if (current > limit.requests) {
           this.metricsService.incrementSecurityEvent('rate_limit_exceeded');
           
           return res.status(429).json({
             statusCode: 429,
             message: 'Too many requests',
             retryAfter: ttl,
           });
         }
         
         next();
       } catch (error) {
         // Fallback to in-memory rate limiting
         this.fallbackRateLimit(req, res, next, clientId, endpoint, limit);
       }
     }
   
     private getClientId(req: Request): string {
       // Use user ID if authenticated
       if (req.user?.id) {
         return `user:${req.user.id}`;
       }
       
       // Use IP address
       return `ip:${req.ip}`;
     }
   
     private getEndpointKey(path: string): string {
       for (const endpoint of Object.keys(this.limits)) {
         if (path.startsWith(endpoint)) {
           return endpoint;
         }
       }
       return 'default';
     }
   
     private fallbackRateLimit(
       req: Request,
       res: Response,
       next: NextFunction,
       clientId: string,
       endpoint: string,
       limit: { requests: number; window: number }
     ) {
       const key = `${clientId}:${endpoint}`;
       const now = Date.now();
       const entry = this.limiter.get(key);
       
       if (!entry || now > entry.resetTime) {
         this.limiter.set(key, { count: 1, resetTime: now + limit.window });
         return next();
       }
       
       if (entry.count >= limit.requests) {
         return res.status(429).json({
           statusCode: 429,
           message: 'Too many requests',
           retryAfter: Math.ceil((entry.resetTime - now) / 1000),
         });
       }
       
       entry.count++;
       next();
     }
   
     private cleanup() {
       const now = Date.now();
       for (const [key, entry] of this.limiter.entries()) {
         if (now > entry.resetTime) {
           this.limiter.delete(key);
         }
       }
     }
   }
   ```

2. **Request Logging & Monitoring (60 دقيقة)**
   ```typescript
   // Security Logging Middleware
   @Injectable()
   export class SecurityLoggingMiddleware implements NestMiddleware {
     constructor(
       private readonly logger: Logger,
       private readonly metricsService: MetricsService,
     ) {}
   
     use(req: Request, res: Response, next: NextFunction) {
       const startTime = Date.now();
       const requestId = uuidv4();
       
       // Add request ID to headers
       req.headers['x-request-id'] = requestId;
       res.setHeader('X-Request-ID', requestId);
       
       // Log request
       this.logRequest(req, requestId);
       
       // Monitor suspicious patterns
       this.detectSuspiciousActivity(req);
       
       // Override res.end to log response
       const originalEnd = res.end;
       res.end = function(chunk?: any) {
         const duration = Date.now() - startTime;
         
         // Log response
         this.logResponse(req, res, duration, requestId);
         
         // Call original end
         originalEnd.call(res, chunk);
       }.bind(this);
       
       next();
     }
   
     private logRequest(req: Request, requestId: string) {
       const logData = {
         requestId,
         method: req.method,
         url: req.url,
         userAgent: req.headers['user-agent'],
         ip: req.ip,
         userId: req.user?.id,
         timestamp: new Date().toISOString(),
       };
       
       // Log sensitive endpoints with more detail
       if (this.isSensitiveEndpoint(req.path)) {
         this.logger.warn('Sensitive endpoint accessed', logData);
       } else {
         this.logger.log('Request received', logData);
       }
     }
   
     private logResponse(req: Request, res: Response, duration: number, requestId: string) {
       const logData = {
         requestId,
         method: req.method,
         url: req.url,
         statusCode: res.statusCode,
         duration,
         userId: req.user?.id,
         timestamp: new Date().toISOString(),
       };
       
       if (res.statusCode >= 400) {
         this.logger.error('Request failed', logData);
         this.metricsService.incrementSecurityEvent('request_failed');
       } else {
         this.logger.log('Request completed', logData);
       }
       
       // Record metrics
       this.metricsService.recordRequestDuration(req.method, req.path, res.statusCode, duration);
     }
   
     private detectSuspiciousActivity(req: Request) {
       const suspiciousPatterns = [
         // SQL Injection patterns
         /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION)\b)/i,
         
         // XSS patterns
         /<script[^>]*>.*?<\/script>/gi,
         /javascript:/gi,
         /on\w+\s*=/gi,
         
         // Path traversal
         /\.\.\//g,
         /\.\.\\/g,
         
         // Command injection
         /[;&|`$()]/g,
       ];
       
       const checkString = `${req.url} ${JSON.stringify(req.query)} ${JSON.stringify(req.body)}`;
       
       for (const pattern of suspiciousPatterns) {
         if (pattern.test(checkString)) {
           this.logger.warn('Suspicious activity detected', {
             ip: req.ip,
             userAgent: req.headers['user-agent'],
             url: req.url,
             pattern: pattern.toString(),
             userId: req.user?.id,
           });
           
           this.metricsService.incrementSecurityEvent('suspicious_activity');
           break;
         }
       }
     }
   
     private isSensitiveEndpoint(path: string): boolean {
       const sensitivePatterns = [
         '/auth/',
         '/admin/',
         '/users/',
         '/payments/',
       ];
       
       return sensitivePatterns.some(pattern => path.includes(pattern));
     }
   }
   ```

**التطبيق العملي:**
- تطبيق security headers
- إعداد CORS policies
- تطبيق rate limiting

---

